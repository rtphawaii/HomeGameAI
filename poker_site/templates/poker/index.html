{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>HomeGame</title>
  <link rel="stylesheet" href="{% static 'styles.css' %}" />
</head>
<body>

  <header class="site-header">
    <img
      class="logo"
      src="{% static 'images/homegamelogo.png' %}"
      alt="HomeGame Poker"
      width="320"
      height="auto"
      decoding="async"
      fetchpriority="high"
    />
  </header>

  <!-- board box -->
  <div id="board-display">Board: (Waiting for cards...)</div>

  <!-- Players Bar -->
  <div id="players-strip" class="players-strip" aria-label="Players at table">
    <!-- Cards injected by JS -->
    <div id="turn-indicator" class="turn-indicator" aria-hidden="true"></div>
  </div>

  <!-- pot and bet -->
  <div class="hud-row">
    <div id="pot-display">Pot: $0</div>
    <div id="bet-display">Bet: $0</div>
  </div>

  <!-- chat + right column -->
  <div class="container">
    <div id="chat-section">
      <div id="chat-log"></div>

      <div class="chat-controls">
        <input id="chat-message-input" type="text" placeholder="Type your move..." />
        <button id="send">Send</button>
        <button id="all-in-btn" disabled>All-In</button>
      </div>
    </div>

    <div id="right-col">
      <section id="hand-panel" class="panel" aria-live="polite" aria-label="Player Hand">
        <div id="hand-display"></div>
      </section>

      <section id="player-info" class="panel">
        <h3>Player Info</h3>
        <div id="player-stats"></div>
      </section>

      <div id="add-balance" class="add-balance panel">
        <label for="amount-input">Add Balance ($):</label>
        <input id="amount-input" type="number" min="0.01" step="0.01" placeholder="e.g. 10.00" />
        <button id="add-btn" type="button">Add</button>
      </div>
    </div>
  </div>

  <!-- Action bar -->
  <div class="action-bar">
    <button id="restart-btn">Restart Game</button>
    <button id="start-round-btn" type="button" aria-label="Start New Round" disabled>
      Start New Round
    </button>
  </div>

  <script>
    // ======== Bootstrap user + room ========
    const baseUserId = '{{ user_id }}';
    const roomName   = '{{ room_name }}';

    // Unique per tab
    const rnd = (crypto?.getRandomValues
      ? crypto.getRandomValues(new Uint32Array(1))[0].toString(36)
      : Math.random().toString(36).slice(2));
    const userId = `${baseUserId}-${rnd}`;
    console.log("Full userId (tab):", userId);

    // ======== UI helpers ========
    function setMyTurn(isMyTurn) {
      const allInBtn = document.getElementById("all-in-btn");
      if (!allInBtn) return;
      allInBtn.disabled = !isMyTurn;
      allInBtn.style.opacity = isMyTurn ? "1" : "0.6";
    }

    const startBtn = document.getElementById("start-round-btn");
    function setStartRoundReady(ready) {
      if (!startBtn) return;
      startBtn.disabled = !ready;
    }

    // Small utilities
    function enable(el)  { el?.removeAttribute?.("disabled"); }
    function disable(el) { el?.setAttribute?.("disabled", "true"); }
    function $(id)       { return document.getElementById(id); }

    // ======== Players Bar state + helpers ========
    const $strip = document.getElementById('players-strip');
    const $puck  = document.getElementById('turn-indicator');

    let _playersById = new Map();
    let _order       = [];
    let _dealerIndex = 0;
    let _activeId    = null;

    // Avatar markup (image if provided, else initials)
    function avatarMarkup(player) {
      const safeName = (player.name || "Player").trim();
      const initials = safeName.split(/\s+/).map(s => s[0]).slice(0,2).join('').toUpperCase();
      if (player.avatarUrl) {
        // No letters in the image; these are your generic SVGs served from /static/avatars/generic-*.svg
        return `
          <div class="avatar" title="${safeName}">
            <img src="${player.avatarUrl}" alt="${safeName}" onerror="this.style.display='none'">
            <span class="avatar-fallback">${initials}</span>
          </div>`;
      }
      return `<div class="avatar avatar-initials" title="${safeName}">${initials}</div>`;
    }

    function positionLabel(i, n) {
      if (n === 2) return i === _dealerIndex ? "BTN/SB" : "BB";
      const rel = (i - _dealerIndex + n) % n; // 0 = BTN
      if (rel === 0) return "BTN";
      if (rel === 1) return "SB";
      if (rel === 2) return "BB";
      if (rel === n - 1) return "CO";
      if (rel === 3) return "UTG";
      if (rel === 4) return "UTG+1";
      return `MP${rel - 2}`;
    }

    function cardMarkup(p, i, n) {
      const pos = positionLabel(i, n);
      const bal = Number(p.balance ?? 0).toFixed(2);
      const activeClass = (String(p.id) === _activeId) ? ' active' : '';
      return `
        <div class="player-card${activeClass}" data-id="${String(p.id)}">
          <div class="player-top">
            ${avatarMarkup(p)}
            <div class="name" title="${p.name}">${p.name}</div>
            <div class="pos-tag" title="${pos}">${pos}</div>
          </div>
          <div class="player-bottom">
            <div class="balance" data-bal-for="${String(p.id)}">$${bal}</div>
            <div class="status-chip" data-status-for="${String(p.id)}">—</div>
          </div>
        </div>
      `;
    }

    function _render() {
      const n = _order.length;
      const cards = _order.map((pid, i) => {
        const p = _playersById.get(pid) || {id: pid, name: pid, balance: 0};
        return cardMarkup(p, i, n);
      }).join('');
      $strip.innerHTML = cards;
      // keep puck as last child
      $strip.appendChild($puck);
      if (_activeId) {
        setTimeout(() => setCurrentTurn(_activeId, true), 0);
      } else {
        $puck.classList.add('hidden');
      }
    }

    // Public API: init, balances, turn, status
    window.initPlayersStrip = function(players, orderIds, dealerIndex = 0) {
      _playersById = new Map(players.map(p => [String(p.id), p]));
      _order       = orderIds.map(String);
      _dealerIndex = Number.isInteger(dealerIndex) ? dealerIndex : 0;
      _render();
    };

    window.updateBalances = function(deltaBalances) {
      Object.entries(deltaBalances || {}).forEach(([pid, bal]) => {
        const p = _playersById.get(String(pid));
        if (p) {
          p.balance = bal;
          const el = $strip.querySelector(`.balance[data-bal-for="${CSS.escape(String(pid))}"]`);
          if (el) el.textContent = `$${Number(bal).toFixed(2)}`;
        }
      });
    };

    window.setCurrentTurn = function(playerId, noScroll) {
      _activeId = String(playerId);
      // toggle styles
      $strip.querySelectorAll('.player-card').forEach(card => card.classList.remove('active'));
      const card = $strip.querySelector(`.player-card[data-id="${CSS.escape(_activeId)}"]`);
      if (!card) { $puck.classList.add('hidden'); return; }
      card.classList.add('active');

      // move puck
      const stripRect = $strip.getBoundingClientRect();
      const cardRect  = card.getBoundingClientRect();
      const x = (cardRect.left - stripRect.left) + (cardRect.width - $puck.offsetWidth) / 2 + $strip.scrollLeft;
      $puck.style.transform = `translateX(${Math.max(0, x)}px)`;
      $puck.classList.remove('hidden');

      // keep in view
      if (!noScroll) {
        const margin = 20;
        const leftNeeded  = card.offsetLeft - margin;
        const rightNeeded = (card.offsetLeft + card.offsetWidth + margin) - ($strip.scrollLeft + $strip.clientWidth);
        if (leftNeeded < $strip.scrollLeft) {
          $strip.scrollTo({ left: leftNeeded, behavior: 'smooth' });
        } else if (rightNeeded > 0) {
          $strip.scrollTo({ left: $strip.scrollLeft + rightNeeded, behavior: 'smooth' });
        }
      }

      // status hint
      const status = $strip.querySelector(`.status-chip[data-status-for="${CSS.escape(_activeId)}"]`);
      if (status) status.textContent = 'To act';
      $strip.setAttribute('aria-live', 'polite');
    };

    window.setPlayerStatus = function(playerId, text) {
      const el = $strip.querySelector(`.status-chip[data-status-for="${CSS.escape(String(playerId))}"]`);
      if (el) el.textContent = text;
    };

    // ======== Board + Hand rendering ========
    const CARD_BASE = "{% static 'cards/' %}";
    const RANK_MAP = {'ACE':'ace','KING':'king','QUEEN':'queen','JACK':'jack','TEN':'10','NINE':'9','EIGHT':'8','SEVEN':'7','SIX':'6','FIVE':'5','FOUR':'4','THREE':'3','TWO':'2'};
    const SUIT_MAP = {'SPADE':'spades','SPADES':'spades','HEART':'hearts','HEARTS':'hearts','DIAMOND':'diamonds','DIAMONDS':'diamonds','CLUB':'clubs','CLUBS':'clubs'};
    const SUIT_SYMBOL = { spades:'♠', hearts:'♥', diamonds:'♦', clubs:'♣' };

    function filenameFor(rankRaw, suitRaw) {
      const rank = RANK_MAP[String(rankRaw).toUpperCase()];
      const suit = SUIT_MAP[String(suitRaw).toUpperCase()];
      return (rank && suit) ? `${rank}_of_${suit}.png` : null;
    }
    function prettyRank(rankRaw) {
      const m = {'ACE':'Ace','KING':'King','QUEEN':'Queen','JACK':'Jack','TEN':'10','NINE':'9','EIGHT':'8','SEVEN':'7','SIX':'6','FIVE':'5','FOUR':'4','THREE':'3','TWO':'2'};
      return m[String(rankRaw).toUpperCase()] || rankRaw;
    }
    function prettySuit(s) { return s.charAt(0).toUpperCase() + s.slice(1); }

    function renderBoard(boardStr) {
      const container = $('board-display');
      container.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'board-cards';
      container.appendChild(wrap);

      const parts = boardStr.split(',').map(s => s.trim());
      for (const part of parts) {
        const m = part.match(/^([\w]+)\s+of\s+([\w]+)$/i);
        if (!m) continue;
        const [, rankRaw, suitRaw] = m;

        const fname = filenameFor(rankRaw, suitRaw);
        if (!fname) continue;

        const rankLabel = prettyRank(rankRaw);
        const suitKey   = SUIT_MAP[String(suitRaw).toUpperCase()];
        const suitNice  = prettySuit(suitKey);
        const symbol    = SUIT_SYMBOL[suitKey];

        const fig = document.createElement('figure');
        fig.className = 'card';

        const img = document.createElement('img');
        img.src = CARD_BASE + fname;
        img.alt = `${rankLabel} of ${suitNice}`;
        img.className = 'card-img';
        img.onerror = () => {
          const span = document.createElement('span');
          span.className = 'card-fallback';
          span.textContent = `${rankLabel} of ${suitNice}`;
          img.replaceWith(span);
        };

        const cap = document.createElement('figcaption');
        cap.className = 'card-caption';
        cap.textContent = `${rankLabel} of ${suitNice}${symbol ? ' ' + symbol : ''}`;

        fig.appendChild(img);
        fig.appendChild(cap);
        wrap.appendChild(fig);
      }
    }

    function fnameFromPair([rankRaw, suitRaw]) {
      const rank = RANK_MAP[String(rankRaw).toUpperCase()];
      const suit = SUIT_MAP[String(suitRaw).toUpperCase()];
      return (rank && suit) ? `${rank}_of_${suit}.png` : null;
    }
    const SUIT_PRETTY = { spades:'Spades', hearts:'Hearts', diamonds:'Diamonds', clubs:'Clubs' };
    const SUIT_EMOJI  = { spades:'♠', hearts:'♥', diamonds:'♦', clubs:'♣' };
    function prettyFromPair([rankRaw, suitRaw]) {
      const r = RANK_MAP[String(rankRaw).toUpperCase()];
      const s = SUIT_MAP[String(suitRaw).toUpperCase()];
      const rankNice = {'ace':'Ace','king':'King','queen':'Queen','jack':'Jack','10':'10','9':'9','8':'8','7':'7','6':'6','5':'5','4':'4','3':'3','2':'2'}[r];
      const suitNice = s ? SUIT_PRETTY[s] : '';
      const sym = s ? SUIT_EMOJI[s] : '';
      return `${rankNice} of ${suitNice}${sym ? ' ' + sym : ''}`.trim();
    }

    function renderHand(handPairs) {
      const container = $('hand-display');
      container.innerHTML = '';
      if (!Array.isArray(handPairs) || handPairs.length === 0) {
        container.textContent = 'Hand: (waiting...)';
        return;
      }
      const wrap = document.createElement('div');
      wrap.className = 'hand-cards';
      container.appendChild(wrap);
      for (const pair of handPairs) {
        const fname = fnameFromPair(pair);
        if (!fname) continue;

        const fig = document.createElement('figure');
        fig.className = 'card';

        const img = document.createElement('img');
        img.src = CARD_BASE + fname;
        img.alt = prettyFromPair(pair);
        img.className = 'card-img';
        img.onerror = () => {
          const fb = document.createElement('span');
          fb.className = 'card-fallback';
          fb.textContent = prettyFromPair(pair);
          img.replaceWith(fb);
        };

        const cap = document.createElement('figcaption');
        cap.className = 'card-caption';
        cap.textContent = prettyFromPair(pair);

        fig.appendChild(img);
        fig.appendChild(cap);
        wrap.appendChild(fig);
      }
    }

    // ======== Player info (right panel) ========
    function updatePlayerStats(player) {
      const stats = $('player-stats');
      stats.innerHTML = `
        <div class="player-stat"><strong>Name:</strong> ${player.name}</div>
        <div class="player-stat"><strong>Balance:</strong> $${Number(player.balance).toFixed(2)}</div>
        <div class="player-stat"><strong>Current Bet:</strong> ${Number(player.currentbet).toFixed(2)}</div>
        <div class="player-stat"><strong>Hand Score:</strong> ${player.handscore ?? ''}</div>
      `;
    }

    // ======== Socket handling ========
    async function handleSocketMessage(data) {
      console.log("Received:", data);

      // Debug who I am
      if (data?.debug_user_id) {
        console.log("[DEBUG] server sees me as:", data.debug_user_id);
      }

      // Turn control (All-In)
      if (data?.action === "your_turn")  enable($("all-in-btn"));
      if (data?.action === "turn_end")   disable($("all-in-btn"));

      // Start Round button cues
      if (data?.action === "start_round_prompt" || data?.can_start_new_round === true || data?.next_round_ready === true || data?.action === "hand_over") {
        setStartRoundReady(true);
      }
      if (data?.action === "round_started" || data?.round === 1) {
        setStartRoundReady(false);
      }

      // Hard reset
      if (data?.reset) {
        $("board-display").textContent = "Board: (Waiting for cards...)";
        $("pot-display").textContent   = "Pot: $0";
        $("bet-display").textContent   = "Bet: $0";
        $("hand-display").innerHTML    = "";
        $("player-stats").innerHTML    = "";
        return;
      }

      // Chat
      if (data?.message) {
        const chatLog = $("chat-log");
        if (chatLog) {
          const msg = document.createElement("div");
          msg.textContent = data.message;
          chatLog.appendChild(msg);
          chatLog.scrollTop = chatLog.scrollHeight;
        }
      }

      // Private player update (my hand, etc.)
      if (data?.player) {
        updatePlayerStats(data.player);
        if (data.player.hand) renderHand(data.player.hand);
      }

      // Board
      if (data?.board) {
        if (data.board.clear) {
          $("board-display").textContent = "Board: (Waiting for cards...)";
        } else if (data.board.board) {
          renderBoard(data.board.board);
        }
      }

      // Pot/Bet
      if (data?.pot) $("pot-display").textContent = `Pot: $${Number(data.pot.pot).toFixed(2)}`;
      if (data?.bet) $("bet-display").textContent = `Bet: $${Number(data.bet.amount).toFixed(2)}`;

      // Players Bar — full state
      if (data?.type === "players_state") {
        try {
          const players = Array.isArray(data.players) ? data.players : [];
          const order   = Array.isArray(data.order)   ? data.order   : [];
          const dealer  = Number.isInteger(data.dealer_index) ? data.dealer_index : 0;

          initPlayersStrip(players, order, dealer);
          if (data.active_player_id) setCurrentTurn(String(data.active_player_id));
        } catch (e) {
          console.warn("[players_state] render failed:", e);
        }
      }

      // Players Bar — turn update (move puck)
      if (data?.type === "turn_update" && data.player_id) {
        try { setCurrentTurn(String(data.player_id)); }
        catch (e) { console.warn("[turn_update] failed:", e); }
      }

      // Players Bar — balances delta
      if (data?.type === "balance_update" && data.balances) {
        try { updateBalances(data.balances); }
        catch (e) { console.warn("[balance_update] failed:", e); }
      }

      // Players Bar — status (Folded / All-in / etc.)
      if (data?.type === "player_status" && data.player_id && typeof data.status === "string") {
        try { setPlayerStatus(String(data.player_id), data.status); }
        catch (e) { console.warn("[player_status] failed:", e); }
      }

      // Redundant safety
      if (data?.action === "your_turn") enable($("all-in-btn"));
      if (data?.action === "turn_end")  disable($("all-in-btn"));
      if (data?.action === "hand_over") enable($("all-in-btn"));
    }

    // Reposition puck on resize
    window.addEventListener("resize", () => {
      if (_activeId) setCurrentTurn(_activeId, true);
    });

    // ======== Create Socket ========
    function createSocket() {
      const socket = new WebSocket(
        (location.protocol === 'https:' ? 'wss://' : 'ws://') +
        location.host + '/ws/chat/' + encodeURIComponent(roomName) +
        '/?user_id=' + encodeURIComponent(userId)
      );

      socket.onopen = () => {
        console.log('[WS] Connected ✅');
        const chatLog = $('chat-log');
        if (chatLog) {
          const msg = document.createElement('div');
          msg.textContent = '[System] Connected to server ✅';
          chatLog.appendChild(msg);
        }
      };

      socket.onclose = (e) => {
        console.warn('[WS] Closed. Retrying in 3s...', e?.reason);
        setTimeout(() => { window.chatSocket = createSocket(); }, 3000);
      };

      socket.onerror = (err) => {
        console.error('[WS] Error:', err);
        socket.close();
      };

      socket.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          handleSocketMessage(data);
        } catch (err) {
          console.error("[WS] bad JSON", err, e.data);
        }
      };

      return socket;
    }

    // Global socket
    window.chatSocket = createSocket();

    // ======== Action bar buttons ========
    $('restart-btn')?.addEventListener('click', () => {
      if (window.chatSocket?.readyState === WebSocket.OPEN) {
        window.chatSocket.send(JSON.stringify({ type: 'control', cmd: 'restart_game' }));
      } else {
        alert('Connection not open yet. Try again in a moment.');
      }
    });

    startBtn?.addEventListener('click', () => {
      if (window.chatSocket?.readyState !== WebSocket.OPEN) {
        console.warn('[START ROUND] socket not open');
        return;
      }
      window.chatSocket.send(JSON.stringify({ message: 'start new round' }));
      setStartRoundReady(false);
    });

    setInterval(() => {
      if (window.chatSocket?.readyState === WebSocket.OPEN) {
        window.chatSocket.send(JSON.stringify({ type: 'ping' }));
      }
    }, 20000);

    // ======== Chat send ========
    $('send').onclick = function () {
      const field = $('chat-message-input');
      const msg = field.value.trim();
      if (!msg) return;
      if (window.chatSocket?.readyState === WebSocket.OPEN) {
        window.chatSocket.send(JSON.stringify({ message: msg }));
      } else {
        console.warn('[CHAT] socket not open');
      }
      field.value = '';
    };

    // Enter key to send
    const input = $('chat-message-input');
    input.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        $('send').click();
      }
    });

    // ======== Add Balance ========
    function parseAmount(v) {
      if (typeof v !== "string") v = String(v ?? "");
      const m = v.trim().match(/^[$+]?(\d+(?:\.\d{1,2})?)$/);
      return m ? parseFloat(m[1]) : NaN;
    }

    const addBtn = $('add-btn');
    if (addBtn) {
      const addHandler = (e) => {
        if (e && e.type === "touchend") e.preventDefault();
        const field = $('amount-input');
        const raw = field ? field.value : "";
        const amount = parseAmount(raw);
        if (isNaN(amount) || amount <= 0) {
          alert("Enter a valid positive number (e.g., 10 or 10.00).");
          return;
        }
        if (window.chatSocket?.readyState === WebSocket.OPEN) {
          window.chatSocket.send(JSON.stringify({
            type: "add_balance",
            target_user_id: userId,
            amount
          }));
          console.log("[ADD] sent", amount, "for", userId);
        } else {
          console.warn("[ADD] socket not open");
        }
        if (field) field.value = "";
      };
      addBtn.addEventListener("click", addHandler, { passive: true });
      addBtn.addEventListener("touchend", addHandler, { passive: false });
    }

    // ======== All-In button ========
    const allInBtn = $('all-in-btn');
    if (allInBtn) {
      allInBtn.addEventListener('click', () => {
        if (window.chatSocket?.readyState === WebSocket.OPEN) {
          window.chatSocket.send(JSON.stringify({ message: 'all-in' }));
          allInBtn.disabled = true; // optimistic
        } else {
          console.warn('[ALL-IN] socket not open');
        }
      });
    }
  </script>
</body>
</html>
