{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>HomeGame</title>
  <link rel="stylesheet" href="{% static 'styles.css' %}" />
</head>
<body>

  <header class="site-header">
    <img
      class="logo"
      src="{% static 'images/homegamelogo.png' %}"
      alt="HomeGame Poker"
      width="320"
      height="auto"
      decoding="async"
      fetchpriority="high"
    />
  </header>

  <!-- Board -->
  <div id="board-display">Board: (Waiting for cards...)</div>
  <!-- anchor used only on mobile to place the hand panel -->
<div id="hand-mobile-anchor"></div>


  <!-- Players Bar (NEW) -->
  <div id="players-strip" class="players-strip" aria-label="Players at table">
    <!-- Player cards are injected by JS -->
    <div id="turn-indicator" class="turn-indicator" aria-hidden="true"></div>
  </div>

  <!-- Pot & Bet -->
  <div class="hud-row">
    <div id="pot-display">Pot: $0</div>
    <div id="bet-display">Bet: $0</div>
  </div>

  <!-- Chat / Right column -->
  <div class="container">
    <div id="chat-section">
      <div id="chat-log"></div>

      <div class="chat-controls">
        <input id="chat-message-input" type="text" placeholder="Type your move..." />
        <button id="send">Send</button>
        <button id="all-in-btn" disabled>All-In</button>
      </div>
    </div>

    <div id="right-col">
      <section id="hand-panel" class="panel" aria-live="polite" aria-label="Player Hand">
        <div id="hand-display"></div>
      </section>

      <section id="player-info" class="panel">
        <h3>Player Info</h3>
        <div id="player-stats"></div>
      </section>

      <div id="add-balance" class="add-balance panel">
        <label for="amount-input">Add Balance ($):</label>
        <input id="amount-input" type="number" min="0.01" step="0.01" placeholder="e.g. 10.00" />
        <button id="add-btn" type="button">Add</button>
      </div>
    </div>
  </div>

  <!-- Action bar -->
  <div class="action-bar">
    <button id="restart-btn">Restart Game</button>
    <button id="start-round-btn" type="button" aria-label="Start New Round" disabled>
      Start New Round
    </button>
  </div>

<script>
  const baseUserId = '{{ user_id }}';
  const roomName   = '{{ room_name }}';
  const roomType   = '{{ room_type }}'; // "cpu"

  // Unique per tab
  const rnd = (crypto?.getRandomValues
    ? crypto.getRandomValues(new Uint32Array(1))[0].toString(36)
    : Math.random().toString(36).slice(2));
  const userId = `${baseUserId}-${rnd}`;
  console.log("[CPU INDEX] userId:", userId, "room:", roomName, "type:", roomType);

  // ---------- UI helpers ----------
  function setMyTurn(isMyTurn) {
    const allInBtn = document.getElementById("all-in-btn");
    if (!allInBtn) return;
    allInBtn.disabled = !isMyTurn;
    allInBtn.style.opacity = isMyTurn ? "1" : "0.6";
  }
  const startBtn = document.getElementById("start-round-btn");
  function setStartRoundReady(ready) { if (startBtn) startBtn.disabled = !ready; }
  function enable(el)  { el?.removeAttribute?.("disabled"); }
  function disable(el) { el?.setAttribute?.("disabled", "true"); }
  function $(id)       { return document.getElementById(id); }

  // ---------- Players Bar state (NEW) ----------
  const $strip = $('players-strip');
  const $puck  = $('turn-indicator');

  let _playersById = new Map();
  let _order       = [];
  let _dealerIndex = 0;
  let _activeId    = null;

  // Deterministic generic avatar color (1..8) by id hash
  function fallbackAvatarFor(id) {
    const idx = [...String(id)].reduce((a,c)=>a+c.charCodeAt(0),0) % 8;
    const n = (idx + 1); // 1..8
    return `{% static 'avatars/' %}` + `generic-${n}.svg`;
  }

  function avatarMarkup(player) {
    // Always use generic colored image; no letters.
    const url = player.avatarUrl || fallbackAvatarFor(player.id);
    const name = player.name || 'Player';
    return `
      <div class="avatar" title="${name}">
        <img src="${url}" alt="${name}" />
      </div>
    `;
  }

  function positionLabel(i, n) {
    if (n === 2) return i === _dealerIndex ? "BTN/SB" : "BB";
    const rel = (i - _dealerIndex + n) % n; // 0 = BTN
    if (rel === 0) return "BTN";
    if (rel === 1) return "SB";
    if (rel === 2) return "BB";
    if (rel === n - 1) return "CO";
    if (rel === 3) return "UTG";
    if (rel === 4) return "UTG+1";
    return `MP${rel - 2}`;
  }

  function cardMarkup(p, i, n) {
    const pos = positionLabel(i, n);
    const bal = Number(p.balance ?? 0).toFixed(2);
    const activeClass = (String(p.id) === _activeId) ? ' active' : '';
    return `
      <div class="player-card${activeClass}" data-id="${String(p.id)}">
        <div class="player-top">
          ${avatarMarkup(p)}
          <div class="name" title="${p.name}">${p.name}</div>
          <div class="pos-tag" title="${pos}">${pos}</div>
        </div>
        <div class="player-bottom">
          <div class="balance" data-bal-for="${String(p.id)}">$${bal}</div>
          <div class="status-chip" data-status-for="${String(p.id)}">—</div>
        </div>
      </div>
    `;
  }

  function renderPlayersStrip() {
    const n = _order.length;
    const cards = _order.map((pid, i) => {
      const p = _playersById.get(pid) || { id: pid, name: pid, balance: 0 };
      return cardMarkup(p, i, n);
    }).join('');
    $strip.innerHTML = cards;
    $strip.appendChild($puck);
    if (_activeId) setTimeout(() => setCurrentTurn(_activeId, true), 0);
    else $puck.classList.add('hidden');
  }

  // Public API used by socket events
  window.initPlayersStrip = function(players, orderIds, dealerIndex = 0) {
    _playersById = new Map(players.map(p => [String(p.id), p]));
    _order       = orderIds.map(String);
    _dealerIndex = Number.isInteger(dealerIndex) ? dealerIndex : 0;
    renderPlayersStrip();
  };

  window.updateBalances = function(deltaBalances) {
    Object.entries(deltaBalances || {}).forEach(([pid, bal]) => {
      const p = _playersById.get(String(pid));
      if (p) {
        p.balance = bal;
        const el = $strip.querySelector(`.balance[data-bal-for="${CSS.escape(String(pid))}"]`);
        if (el) el.textContent = `$${Number(bal).toFixed(2)}`;
      }
    });
  };

  window.setPlayerStatus = function(playerId, text) {
    const el = $strip.querySelector(`.status-chip[data-status-for="${CSS.escape(String(playerId))}"]`);
    if (el) el.textContent = text;
  };

  window.setCurrentTurn = function(playerId, noScroll) {
    _activeId = String(playerId);
    $strip.querySelectorAll('.player-card').forEach(card => card.classList.remove('active'));
    const card = $strip.querySelector(`.player-card[data-id="${CSS.escape(_activeId)}"]`);
    if (!card) { $puck.classList.add('hidden'); return; }
    card.classList.add('active');

    // Move puck
    const stripRect = $strip.getBoundingClientRect();
    const cardRect  = card.getBoundingClientRect();
    const x = (cardRect.left - stripRect.left) + (cardRect.width - $puck.offsetWidth) / 2 + $strip.scrollLeft;
    $puck.style.transform = `translateX(${Math.max(0, x)}px)`;
    $puck.classList.remove('hidden');

    // Keep card in view
    if (!noScroll) {
      const margin = 20;
      const leftNeeded  = card.offsetLeft - margin;
      const rightNeeded = (card.offsetLeft + card.offsetWidth + margin) - ($strip.scrollLeft + $strip.clientWidth);
      if (leftNeeded < $strip.scrollLeft) {
        $strip.scrollTo({ left: leftNeeded, behavior: 'smooth' });
      } else if (rightNeeded > 0) {
        $strip.scrollTo({ left: $strip.scrollLeft + rightNeeded, behavior: 'smooth' });
      }
    }

    // Status hint
    const status = $strip.querySelector(`.status-chip[data-status-for="${CSS.escape(_activeId)}"]`);
    if (status) status.textContent = 'To act';
    $strip.setAttribute('aria-live', 'polite');
  };

  // Keep puck correct on resize
  window.addEventListener("resize", () => { if (_activeId) setCurrentTurn(_activeId, true); });

  // ---------- Render helpers (board/hand) ----------
  const CARD_BASE = "{% static 'cards/' %}";
  const RANK_MAP  = {'ACE':'ace','KING':'king','QUEEN':'queen','JACK':'jack','TEN':'10','NINE':'9','EIGHT':'8','SEVEN':'7','SIX':'6','FIVE':'5','FOUR':'4','THREE':'3','TWO':'2'};
  const SUIT_MAP  = {'SPADE':'spades','SPADES':'spades','HEART':'hearts','HEARTS':'hearts','DIAMOND':'diamonds','DIAMONDS':'diamonds','CLUB':'clubs','CLUBS':'clubs'};
  const SUIT_PRETTY = { spades:'Spades', hearts:'Hearts', diamonds:'Diamonds', clubs:'Clubs' };
  const SUIT_EMOJI  = { spades:'♠', hearts:'♥', diamonds:'♦', clubs:'♣' };

  function filenameFor(rankRaw, suitRaw) {
    const rank = RANK_MAP[String(rankRaw).toUpperCase()];
    const suit = SUIT_MAP[String(suitRaw).toUpperCase()];
    return (rank && suit) ? `${rank}_of_${suit}.png` : null;
  }
  function prettyFromPair([rankRaw, suitRaw]) {
    const r = RANK_MAP[String(rankRaw).toUpperCase()];
    const s = SUIT_MAP[String(suitRaw).toUpperCase()];
    const rankNice = {'ace':'Ace','king':'King','queen':'Queen','jack':'Jack','10':'10','9':'9','8':'8','7':'7','6':'6','5':'5','4':'4','3':'3','2':'2'}[r];
    const suitNice = s ? SUIT_PRETTY[s] : '';
    const sym = s ? SUIT_EMOJI[s] : '';
    return `${rankNice} of ${suitNice}${sym ? ' ' + sym : ''}`.trim();
  }

  function renderBoard(boardStr) {
    const container = $('board-display');
    if (!boardStr) { container.textContent = 'Board: (Waiting for cards...)'; return; }
    container.innerHTML = '';
    const wrap = document.createElement('div');
    wrap.className = 'board-cards';
    container.appendChild(wrap);

    const parts = String(boardStr).split(',').map(s => s.trim()).filter(Boolean);
    for (const part of parts) {
      const m = part.match(/^([\w]+)\s+of\s+([\w]+)$/i);
      if (!m) continue;
      const [, rankRaw, suitRaw] = m;

      const fname = filenameFor(rankRaw, suitRaw);
      const fig = document.createElement('figure');
      fig.className = 'card';

      if (fname) {
        const img = document.createElement('img');
        img.src = CARD_BASE + fname;
        img.alt = prettyFromPair([rankRaw, suitRaw]);
        img.className = 'card-img';
        img.onerror = () => {
          const fb = document.createElement('span');
          fb.className = 'card-fallback';
          fb.textContent = prettyFromPair([rankRaw, suitRaw]);
          img.replaceWith(fb);
        };
        fig.appendChild(img);
      } else {
        const fb = document.createElement('span');
        fb.className = 'card-fallback';
        fb.textContent = prettyFromPair([rankRaw, suitRaw]);
        fig.appendChild(fb);
      }

      const cap = document.createElement('figcaption');
      cap.className = 'card-caption';
      cap.textContent = prettyFromPair([rankRaw, suitRaw]);
      fig.appendChild(cap);
      wrap.appendChild(fig);
    }
  }

  function renderHand(handPairs) {
    const container = $('hand-display');
    container.innerHTML = '';
    if (!Array.isArray(handPairs) || handPairs.length === 0) {
      container.textContent = 'Hand: (waiting...)';
      return;
    }
    const wrap = document.createElement('div');
    wrap.className = 'hand-cards';
    container.appendChild(wrap);

    for (const pair of handPairs) {
      const [rankRaw, suitRaw] = pair;
      const fname = filenameFor(rankRaw, suitRaw);

      const fig = document.createElement('figure');
      fig.className = 'card';

      if (fname) {
        const img = document.createElement('img');
        img.src = CARD_BASE + fname;
        img.alt = prettyFromPair(pair);
        img.className = 'card-img';
        img.onerror = () => {
          const fb = document.createElement('span');
          fb.className = 'card-fallback';
          fb.textContent = prettyFromPair(pair);
          img.replaceWith(fb);
        };
        fig.appendChild(img);
      } else {
        const fb = document.createElement('span');
        fb.className = 'card-fallback';
        fb.textContent = prettyFromPair(pair);
        fig.appendChild(fb);
      }

      const cap = document.createElement('figcaption');
      cap.className = 'card-caption';
      cap.textContent = prettyFromPair(pair);
      fig.appendChild(cap);
      wrap.appendChild(fig);
    }
  }

  function updatePlayerStats(player) {
    const stats = $('player-stats');
    stats.innerHTML = `
      <div class="player-stat"><strong>Name:</strong> ${player.name}</div>
      <div class="player-stat"><strong>Balance:</strong> $${player.balance}</div>
      <div class="player-stat"><strong>Current Bet:</strong> ${player.currentbet}</div>
      <div class="player-stat"><strong>Hand Score:</strong> ${player.handscore}</div>
    `;
  }

  // ---------- Socket handler (EXTENDED) ----------
  function handleSocketMessage(data) {
    console.log("[WS][CPU] Received:", data);

    // Turn control
    if (data?.action === "your_turn") enable($("all-in-btn"));
    if (data?.action === "turn_end")  disable($("all-in-btn"));

    // Start New Round cues
    if (
      data?.action === "start_round_prompt" ||
      data?.can_start_new_round === true ||
      data?.next_round_ready === true ||
      data?.action === "hand_over"
    ) setStartRoundReady(true);
    if (data?.action === "round_started") setStartRoundReady(false);

    // Hard reset
    if (data?.reset) {
      $('board-display').textContent = 'Board: (Waiting for cards...)';
      $('pot-display').textContent   = 'Pot: $0';
      $('bet-display').textContent   = 'Bet: $0';
      $('hand-display').innerHTML    = '';
      $('player-stats').innerHTML    = '';
      return;
    }

    // Chat
    if (data?.message) {
      const chatLog = $('chat-log');
      const msg = document.createElement('div');
      msg.textContent = data.message;
      chatLog.appendChild(msg);
      chatLog.scrollTop = chatLog.scrollHeight;
    }

    // Private update (self)
    if (data?.player) {
      updatePlayerStats(data.player);
      if (data.player.hand) renderHand(data.player.hand);
    }

    // Board
    if (data?.board) {
      if (data.board.clear) $('board-display').textContent = 'Board: (Waiting for cards...)';
      else if (data.board.board) renderBoard(data.board.board);
    }

    // Pot / Bet
    if (data?.pot) $('pot-display').textContent = `Pot: $${Number(data.pot.pot).toFixed(2)}`;
    if (data?.bet) $('bet-display').textContent = `Bet: $${Number(data.bet.amount).toFixed(2)}`;

    // Players Bar: full state
    // { type:"players_state", players:[{id,name,balance,currentbet,avatarUrl?}], order:["id"...], dealer_index:0, active_player_id? }
    if (data?.type === "players_state") {
      const players = Array.isArray(data.players) ? data.players : [];
      const order   = Array.isArray(data.order)   ? data.order   : [];
      const dealer  = Number.isInteger(data.dealer_index) ? data.dealer_index : 0;
      initPlayersStrip(players, order, dealer);
      if (data.active_player_id) setCurrentTurn(String(data.active_player_id));
    }

    // Players Bar: turn update
    if (data?.type === "turn_update" && data.player_id) {
      setCurrentTurn(String(data.player_id));
    }

    // Players Bar: balances delta
    if (data?.type === "balance_update" && data.balances) {
      updateBalances(data.balances);
    }

    // Players Bar: status chip
    if (data?.type === "player_status" && data.player_id && typeof data.status === "string") {
      setPlayerStatus(String(data.player_id), data.status);
    }
  }

  // ---------- Socket creation ----------
  function createSocket() {
    const proto = (location.protocol === 'https:' ? 'wss://' : 'ws://');
    const url = proto + location.host +
      '/ws/chat/' + encodeURIComponent(roomName) +
      '/?user_id=' + encodeURIComponent(userId) +
      '&room_type=' + encodeURIComponent(roomType);

    const socket = new WebSocket(url);

    socket.onopen = () => {
      console.log('[WS][CPU] Connected ✅');
      const chatLog = $('chat-log');
      if (chatLog) {
        const msg = document.createElement('div');
        msg.textContent = '[System] Connected to server ✅';
        chatLog.appendChild(msg);
      }
    };

    socket.onmessage = (e) => {
      try { handleSocketMessage(JSON.parse(e.data)); }
      catch (err) { console.error("[WS][CPU] bad JSON", err, e.data); }
    };

    socket.onclose = (e) => {
      console.warn('[WS][CPU] Closed. Retrying in 3s...', e?.reason);
      setTimeout(() => { window.chatSocket = createSocket(); }, 3000);
    };

    socket.onerror = (err) => {
      console.error('[WS][CPU] Error:', err);
      socket.close();
    };

    return socket;
  }

  // Global socket
  window.chatSocket = createSocket();

  // ---------- Action bar ----------
  $('restart-btn')?.addEventListener("click", () => {
    if (window.chatSocket && window.chatSocket.readyState === WebSocket.OPEN) {
      window.chatSocket.send(JSON.stringify({ type: "control", cmd: "restart_game" }));
    } else {
      alert("Connection not open yet. Try again in a moment.");
    }
  });
  startBtn?.addEventListener("click", () => {
    if (!window.chatSocket || window.chatSocket.readyState !== WebSocket.OPEN) {
      console.warn("[START ROUND][CPU] socket not open");
      return;
    }
    window.chatSocket.send(JSON.stringify({ message: "start new round" }));
    setStartRoundReady(false);
  });

  // ---------- Chat ----------
  $('send').onclick = function () {
    const field = $('chat-message-input');
    const msg = field.value.trim();
    if (!msg) return;
    if (window.chatSocket && window.chatSocket.readyState === WebSocket.OPEN) {
      window.chatSocket.send(JSON.stringify({ message: msg }));
    } else {
      console.warn('[CHAT][CPU] socket not open');
    }
    field.value = '';
  };
  $('chat-message-input')?.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      $('send').click();
    }
  });

  // ---------- Add Balance ----------
  function parseAmount(v) {
    if (typeof v !== "string") v = String(v ?? "");
    const m = v.trim().match(/^[$+]?(\d+(?:\.\d{1,2})?)$/);
    return m ? parseFloat(m[1]) : NaN;
  }
  const addBtn = $('add-btn');
  if (addBtn) {
    const addHandler = (e) => {
      if (e && e.type === "touchend") e.preventDefault();
      const field = $('amount-input');
      const raw = field ? field.value : "";
      const amount = parseAmount(raw);
      if (isNaN(amount) || amount <= 0) { alert("Enter a valid number (e.g., 10.00)."); return; }
      if (window.chatSocket && window.chatSocket.readyState === WebSocket.OPEN) {
        window.chatSocket.send(JSON.stringify({ type: "add_balance", target_user_id: userId, amount }));
        console.log("[ADD][CPU] sent", amount, "for", userId);
      } else {
        console.warn("[ADD][CPU] socket not open");
      }
      if (field) field.value = "";
    };
    addBtn.addEventListener("click", addHandler, { passive: true });
    addBtn.addEventListener("touchend", addHandler, { passive: false });
  }

  // ---------- All-In ----------
  const allInBtn = $('all-in-btn');
  if (allInBtn) {
    allInBtn.addEventListener("click", () => {
      if (window.chatSocket && window.chatSocket.readyState === WebSocket.OPEN) {
        window.chatSocket.send(JSON.stringify({ message: "all-in" }));
        allInBtn.disabled = true; // server will confirm with "turn_end"
      } else {
        console.warn("[ALL-IN][CPU] socket not open");
      }
    });
  }

  // ---------- Keep-alive ----------
  setInterval(() => {
    if (window.chatSocket && window.chatSocket.readyState === WebSocket.OPEN) {
      window.chatSocket.send(JSON.stringify({ type: "ping" }));
    }
  }, 20000);

  // ------- Hand panel responsive re-parenting (mobile under board) -------
(function () {
  const handPanel          = document.getElementById('hand-panel');
  const rightCol           = document.getElementById('right-col');
  const handMobileAnchor   = document.getElementById('hand-mobile-anchor');
  const mq                 = window.matchMedia('(max-width: 700px)');

  if (!handPanel || !rightCol || !handMobileAnchor) return;

  // Put the hand panel right after the board on mobile;
  // put it back at the top of the right column on desktop.
  function placeHand(e) {
    const isMobile = e.matches === true;
    if (isMobile) {
      // If it's not already under the board, move it there.
      if (handPanel.previousElementSibling !== handMobileAnchor) {
        handMobileAnchor.after(handPanel);
      }
    } else {
      // Put it first in the right column for desktop/tablet.
      if (rightCol.firstElementChild !== handPanel) {
        rightCol.prepend(handPanel);
      }
    }
  }

  // Initial placement + react to changes
  placeHand(mq);
  // Modern browsers
  if (mq.addEventListener) {
    mq.addEventListener('change', placeHand);
  } else {
    // Safari <14 fallback
    mq.addListener(placeHand);
  }

  // Optional: also fix after orientation changes (some iOS versions)
  window.addEventListener('orientationchange', () => placeHand(mq));
})();

</script>
</body>
</html>
